"""
problem link: https://rosalind.info/problems/ba10k/
Given: A sequence of emitted symbols x = x1 . . . xn in an alphabet A, generated by a k-state HMM with unknown
transition and emission probabilities, initial Transition and Emission matrices and a number of iterations I.
Return: A matrix of transition probabilities Transition and a matrix of emission probabilities Emission that
maximizes Pr(x,π) over all possible transition and emission matrices and over all hidden paths π.

sample input:
10
--------
xzyyzyzyxy
--------
x   y   z
--------
A   B
--------
    A   B
A   0.019   0.981
B   0.668   0.332
--------
x   y   z
A   0.175   0.003   0.821
B   0.196   0.512   0.293

sample output:
A   B
A   0.000   1.000
B   0.786   0.214
--------
    x   y   z
A   0.242   0.000   0.758
B   0.172   0.828   0.000
"""
from io import StringIO
import numpy as np
import pandas as pd


class HMM:
    def __init__(self, emission, transition, alphabet, states):
        self.emission = emission
        self.transition = transition
        self.alphabet = alphabet
        self.states = states

    def forward_backward(self, evidence):
        forward = np.zeros((len(self.states), len(evidence)))
        backward = np.zeros((len(self.states), len(evidence)))
        evidence_count = len(evidence)
        # initializing first column of dynamic array
        for i in range(len(self.states)):
            forward[i][0] = self.emission[x[0]][self.states[i]]
            backward[i][evidence_count - 1] = 1

        for i in range(1, len(evidence)):
            for j in range(len(self.states)):
                for k in range(len(self.states)):
                    forward[j][i] += forward[k][i - 1] * self.transition[self.states[j]][self.states[k]]
                forward[j][i] *= self.emission[evidence[i]][self.states[j]]

        for i in range(len(evidence) - 2, -1, -1):
            for j in range(len(self.states)):
                for k in range(len(self.states)):
                    backward[j][i] += backward[k][i + 1] * self.transition[self.states[k]][self.states[j]] * \
                                      self.emission[evidence[i + 1]][self.states[k]]

        return forward, backward

    def baum_welch(self, evidence, iteration=10):
        for iter in range(iteration):
            forward_matrix, backward_matrix = self.forward_backward(evidence)
            pi_matrix = forward_matrix * backward_matrix
            pi_matrix = pi_matrix / np.sum(pi_matrix)
            update_matrix = np.zeros((len(evidence) - 1, len(self.states), len(states)))
            for t in range(len(evidence) - 1):
                for i in range(len(states)):
                    for j in range(len(states)):
                        update_matrix[t][i][j] = forward_matrix[i][t] * backward_matrix[j][t + 1] * \
                                                 self.transition[self.states[j]][self.states[i]] * \
                                                 self.emission[evidence[t + 1]][self.states[j]]
            update_matrix = update_matrix / np.sum(forward_matrix, axis=0)[-1]

            # updating transition
            for i in range(len(self.states)):
                for j in range(len(self.states)):
                    self.transition[self.states[j]][self.states[i]] = np.sum(update_matrix, axis=0)[i][j] / \
                                                                      np.sum(pi_matrix[:, :-1], axis=1)[i]
            tmp = np.sum(self.transition, axis=1)
            for j in range(len(self.states)):
                self.transition[self.states[j]] /= tmp[j]

            # updating emission
            for i in range(len(self.states)):
                for j in range(len(self.alphabet)):
                    prob_sum = 0
                    for t in range(len(evidence)):
                        if evidence[t] == self.alphabet[j]:
                            prob_sum += pi_matrix[i][t]
                    self.emission[self.alphabet[j]][self.states[i]] = prob_sum / np.sum(pi_matrix, axis=1)[i]


def transition(pi_star_star):
    t = []
    c = 0
    for i in range(len(states)):
        t.append([])
        for j in range(len(states)):
            t[-1].append(sum(pi_star_star[c]))
            c += 1
    return t


file = open('../Motif Finding/input.txt', 'r')
Lines = file.readlines()
n = int(Lines[0])
x = Lines[2].strip()
alphabet = Lines[4].split()
states = Lines[6].split()
transition = pd.read_csv(StringIO(''.join(Lines[8:9 + len(states)])), delim_whitespace=True, engine='python')
emission = pd.read_csv(StringIO(''.join(Lines[10 + len(states):11 + len(states) * 2])), delim_whitespace=True,
                       engine='python')
hmm = HMM(emission, transition, alphabet, states)
hmm.baum_welch(x, iteration=n)


pd.options.display.float_format = '{:,.3f}'.format
hmm.transition.sort_index(inplace=True)
hmm.emission.sort_index(inplace=True)
print(str(hmm.transition))
print('--------')
print(str(hmm.emission))